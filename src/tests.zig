const std = @import("std");
const root = @import("root.zig");
const cbor = @import("zbor");

test "serialize Version" {
    const v = root.Version{};

    var raw = std.ArrayList(u8).init(std.testing.allocator);
    defer raw.deinit();

    try v.serialize(raw.writer());

    try std.testing.expectEqualSlices(u8, "\x43\x43\x44\x42\x01\x00\x00\x00", raw.items);
}

test "serialize TrailerFields" {
    const allocator = std.testing.allocator;

    const expected = "\xa4\x62\x69\x76\x58\x18\x00\x11\x22\x33\x44\x55\x66\x77\x00\x11\x22\x33\x44\x55\x66\x77\x00\x11\x22\x33\x44\x55\x66\x77\x63\x63\x69\x64\x78\x1e\x43\x43\x44\x42\x5f\x58\x43\x48\x41\x43\x48\x41\x32\x30\x5f\x50\x4f\x4c\x59\x31\x33\x30\x35\x5f\x53\x48\x41\x35\x31\x32\x63\x6b\x64\x66\xa5\x65\x24\x55\x55\x49\x44\x78\x24\x39\x65\x32\x39\x38\x62\x31\x39\x2d\x35\x36\x64\x62\x2d\x34\x37\x37\x33\x2d\x62\x32\x33\x64\x2d\x66\x63\x33\x65\x63\x36\x66\x30\x61\x31\x65\x36\x61\x49\x02\x61\x4d\x19\x4c\x00\x61\x50\x01\x61\x53\x58\x20\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x63\x65\x78\x74\x81\x67\x70\x61\x73\x73\x6b\x65\x79";

    const ext = try allocator.alloc([]const u8, 1);
    ext[0] = try allocator.dupe(u8, "passkey");

    const fields = root.TrailerFields{
        .iv = try allocator.dupe(u8, "\x00\x11\x22\x33\x44\x55\x66\x77\x00\x11\x22\x33\x44\x55\x66\x77\x00\x11\x22\x33\x44\x55\x66\x77"),
        .cid = try allocator.dupe(u8, "CCDB_XCHACHA20_POLY1305_SHA512"),
        .kdf = .{
            .@"$UUID" = "9e298b19-56db-4773-b23d-fc3ec6f0a1e6".*,
            .I = 2,
            .M = 19456,
            .P = 1,
            .S = "\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04".*,
        },
        .ext = ext,
    };
    defer fields.deinit(allocator);

    var raw = std.ArrayList(u8).init(allocator);
    defer raw.deinit();

    try cbor.stringify(fields, .{}, raw.writer());

    try std.testing.expectEqualSlices(u8, expected, raw.items);
}

test "derive encryption key" {
    const allocator = std.testing.allocator;

    const ext = try allocator.alloc([]const u8, 1);
    ext[0] = try allocator.dupe(u8, "passkey");

    const fields = root.TrailerFields{
        .iv = try allocator.dupe(u8, "\x00\x11\x22\x33\x44\x55\x66\x77\x00\x11\x22\x33\x44\x55\x66\x77\x00\x11\x22\x33\x44\x55\x66\x77"),
        .cid = try allocator.dupe(u8, "CCDB_XCHACHA20_POLY1305_SHA512"),
        .kdf = .{
            .@"$UUID" = "9e298b19-56db-4773-b23d-fc3ec6f0a1e6".*,
            .I = 2,
            .M = 19456,
            .P = 1,
            .S = "\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04\x01\x02\x03\x04".*,
        },
        .ext = ext,
    };
    defer fields.deinit(allocator);

    var key: [32]u8 = undefined;
    try fields.deriveEncryptionKey(&key, "supersecret", allocator);

    try std.testing.expectEqualSlices(u8, "\x89\x62\xef\x6d\xa6\x61\x84\x8e\xc9\x0c\x0d\xaf\xb9\xfb\xf3\x14\xac\xd4\xee\xe1\xcc\x0e\x4e\xd6\x4f\xef\xe0\xa1\x49\x64\x2d\x78", &key);
}

test "derive entry key from master secret and index" {
    var ms = root.MasterSecret{
        .ms = "\xde\x5b\x42\xf2\x9d\x10\x6f\x70\x7c\xaa\xaa\xdd\x1e\xf1\x73\x9c\xc9\xc3\xf6\x07\xb5\x51\x8a\x21\x2c\x9e\x64\xa3\xf9\x67\x43\x8b\x90\xa8\xd2\x22\x5b\xb2\x96\x99\xcf\xce\xf4\x41\x76\xf5\x9f\x48\xfb\xc7\xaa\xaa\xaa\x79\x2f\xe6\x0f\x22\xba\xe8\xcd\xdd\x60\xaa".*,
    };
    defer ms.deinit();

    var k: [32]u8 = undefined;

    ms.deriveEntryKey(&k, 0);
    try std.testing.expectEqualSlices(u8, "\x01\x6d\xe7\x5c\xf3\xa2\x44\x87\xfe\x05\x4b\x38\x6d\x94\xb3\xc1\x26\xc4\x37\xd5\xdb\x0d\x6f\xd3\x5b\x4d\xa8\x5d\x19\x09\x47\x1c", &k);

    ms.deriveEntryKey(&k, 10);
    try std.testing.expectEqualSlices(u8, "\x07\xc4\x08\x55\x0a\x5f\x73\x6d\x46\xe7\x46\xcc\x3f\x60\xe6\x13\x50\xdd\x73\x51\xfd\xcc\xe3\xa0\x8a\xe5\x26\x52\xb7\xf8\xd6\xb0", &k);
}

test "derive meta key from master secret" {
    var ms = root.MasterSecret{
        .ms = "\xde\x5b\x42\xf2\x9d\x10\x6f\x70\x7c\xaa\xaa\xdd\x1e\xf1\x73\x9c\xc9\xc3\xf6\x07\xb5\x51\x8a\x21\x2c\x9e\x64\xa3\xf9\x67\x43\x8b\x90\xa8\xd2\x22\x5b\xb2\x96\x99\xcf\xce\xf4\x41\x76\xf5\x9f\x48\xfb\xc7\xaa\xaa\xaa\x79\x2f\xe6\x0f\x22\xba\xe8\xcd\xdd\x60\xaa".*,
    };
    defer ms.deinit();

    var k: [32]u8 = undefined;

    ms.deriveMetaKey(&k);
    try std.testing.expectEqualSlices(u8, "\x17\x24\xb3\x4a\xc0\xc6\x03\x96\x98\xd5\xe7\xae\x35\x05\xef\x1d\x93\xb6\xd6\x59\x37\x72\x33\x0f\x19\x57\x12\x32\x2f\x63\x48\xe8", &k);
}

test "decode encode meta data" {
    const allocator = std.testing.allocator;

    var ms = root.MasterSecret{
        .ms = "\xde\x5b\x42\xf2\x9d\x10\x6f\x70\x7c\xaa\xaa\xdd\x1e\xf1\x73\x9c\xc9\xc3\xf6\x07\xb5\x51\x8a\x21\x2c\x9e\x64\xa3\xf9\x67\x43\x8b\x90\xa8\xd2\x22\x5b\xb2\x96\x99\xcf\xce\xf4\x41\x76\xf5\x9f\x48\xfb\xc7\xaa\xaa\xaa\x79\x2f\xe6\x0f\x22\xba\xe8\xcd\xdd\x60\xaa".*,
    };
    defer ms.deinit();

    const m = try root.Meta.new("PassKeez", "My Passkeys", allocator, &ms);
    defer m.deinit(allocator);

    const gen = try m.getGenAlloc(allocator, &ms);
    defer allocator.free(gen);
    try std.testing.expectEqualSlices(u8, "PassKeez", gen);

    const name = try m.getNameAlloc(allocator, &ms);
    defer allocator.free(name);
    try std.testing.expectEqualSlices(u8, "My Passkeys", name);

    const times = try m.getTimes(&ms);
    const now = std.time.milliTimestamp();
    try std.testing.expect((now - 60_000) < times.creat and times.creat < (now + 60_000));
}
