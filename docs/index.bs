<pre class='metadata'>
Title: CBOR Credential Database Format
Shortname: CCDB 
Level: 1
Status: LD
Repository: https://github.com/r4gus/ccdb
URL: https://r4gus.github.io/ccdb/index.html
Editor: David P. Sugar, david@thesugar.de
Abstract: Specification for the CBOR Credential Database Format (CCDB) providing confidentiality and integrity for credentials and other sensitive data at rest.
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: markdown yes, css no
</pre>

Introduction {#intro}
=====================

This document defines a database format enabling the secure storage of credentials.
At its core, this format encapsulates a robust encryption mechanism, housing all data within a single encrypted file securely stored on users' devices. Encryption is fortified by a secret derived from a source previously designated by the user, typically a password, ensuring that the database remains inaccessible to unauthorized entities. Access to the database content is only granted upon decryption with the corresponding key, guaranteeing the confidentiality and integrity of stored information.

Crafted with security and usability in mind, this format can be of use for applications that require secure storage at rest. Whether it's password managers, FIDO-capable authenticators, or other credential management systems.

The format was designed to fullfill following requirements (see also [[#security]]):

- **Small Memory Footprint at Rest**: The format minimizes storage requirements while maintaining robust encryption standards.
- **Resilience Against Diverse Threats**: This format uses state-of-the-art AEAD ciphers to ensure confidentiality and integrity.
- **Ease of Implementation**: With a focus on simplicity and accessibility, developers can seamlessly integrate this format into their applications.
- **Scalability and Extensibility**: This format is designed with extensibility in mind, accommodating future enhancements and adaptations.

The format builds upon the proven foundation of the Concise Binary Object Representation (CBOR) [[!RFC8949]]. By leveraging CBOR's compact structure and extensibility, the database size is optimized, surpassing conventional formats like [[XML]] in both size and flexibility.

Moreover, the architecture of this format is characterized by its reliance on universally available data types and algorithms. From CBOR de-/serializer libraries boasting minimal code footprint to Authenticated Encryption with Associated Data (AEAD) ciphers widely supported across cryptographic libraries and hardware.

The culmination of these design choices manifests in a format tailor-made for a spectrum of systems, including those with limited resources such as embedded systems. The synergy of compact data size, minimal program overhead, and potential hardware acceleration for supported ciphers positions this format as a versatile solution capable of meeting the stringent security demands of modern applications.

## Conventions ## {#conventions}

: Byte
:: A byte is a value in the range `[0, 255]` that can be represented with 8 bits.

: Unsigned numbers
:: Unsigned numbers are represented as `uN`, a number in the range `[0, 2^n - 1]`, e.g., `u32` is a number between 0 and 4294967295.

: Signed numbers
:: Signed numbers are represented as `iN`, a number in the range `[-2^(N - 1), 2^(n - 1) - 1]`, e.g., `i32` is a number between 2147483648 and 2147483647.

: Endianness
:: All numbers are stored in the little-endian format, e.g., the `u32` number 0x12345678 is stored as `78 56 34 12` consecutively in memory.

: Byte sequence
:: A byte sequence is denoted as `byte[N]` where `N` is the number of consecuitve bytes in memory.

: UUID
:: Certain elements like ciphers and key derivation functions are encoded as Universally Unique IDentifiers [[RFC4122]] with the version 4 (random data).

: String
:: A UTF-8 string.

## CBOR Grammar ## {#cbor-grammar}

This document uses the same grammar as used by [[!RFC8152]]. The CBOR structures are described in prose.

: bool
:: A boolean value (true: major type 7, value 21; false: major type 7, value 20)

: int
:: An unsigned integer or a negative integer.

: uint
:: An unsigned integer (majort type 0)

: nint
:: A negative integer (major type 1)

: bstr
:: Byte string (major type 2)

: tstr
:: Text string (major type 3)

: map
:: A CBOR map (major type 5)

: [+ FOO]
:: Indicates that the type FOO appears one or more times in an array.

Database Format {#db-format}
=====================

The CCDB data consists of a public and a confidential part. The database starts with a public header that encodes the properties of
the database, including its version, followed by a encrypted block that contains the actual, CBOR encoded, data. The integrity of the 
header as well as the confidential block is verified using message authentication codes.

<pre class='railroad'>
N: Outer Header
N: Body Length (u64)
N: AEAD Tag
N: Encrypted Body
</pre>

## Outer Header ## {#outer-header}

The outer header encodes information required to decrypt the remaining database. The overall structure of the outer header can be described as follows:

<pre class='railroad'>
N: Version
N: Header Field Length (u64)
OneOrMore:
    N: Header Field
    Choice:
        N: [=cid=]
        N: [=cmp=]
        N: [=iv=]
        N: [=kdf=]
</pre>

The header begins with the database version ([[#header-version]]) followed by the length of the header fields in bytes, followed by one or more header fields ([[#header-fields]]).

Note: The integrity of the header is validated by the selected AEAD cipher.

<pre class="example">
43 43 44 42 01 00 00 00
|_________| |___| |___|
  "CCDB"      1  .  0

66 00 00 00
|_________|
Header Field Length

A46269764C010203040102030401020304636369640363636D7001636B6466A565245555494
4509E298B1956DB4773B23DFC3EC6F0A1E6614902614D191000615008615358200102030401
020304010203040102030401020304010203040102030401020304
|_________________________________________________________________________|
                         Header Fields
</pre>

### Version ### {#header-version}

The initial 8 bytes encode the CCDB version.

<figure id="version" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Name</th>
            <th>Data Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>sig</dfn></td>
            <td>u32</td>
            <td>
                CCDB 
            </td>
        </tr>
        <tr>
            <td><dfn>major version</dfn></td>
            <td>u16</td>
            <td>
                0x01 for CDF major version 1
            </td>
        </tr>
        <tr>
            <td><dfn>minor version</dfn></td>
            <td>u16</td>
            <td>
                Minor version number, e.g., 0 if the CDF version is 1.0
            </td>
        </tr>
    </table>
</figure>

### Header Fields ### {#header-fields}

The [[#header-version]] is followed by a CBOR map (major type 5) of the following header fields. The keys are encoded
as text strings (major type 3) whereas the value types vary. All listed header fields are mandatory
and SHOULD be encoded in the order listed below.

<figure id="fieldTypes" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Key</th>
            <th>Data Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>cid</dfn></td>
            <td>int</td>
            <td>
                The cipher the database is encrypted with, encoded as integer as defined by [[!RFC9053]] and [[!RFC9054]]. 

                The following ciphers MUST be supported:
                - AES256GCM: 3 
                
                The following ciphers MAY be supported:
            </td>
        </tr>
        <tr>
            <td><dfn>iv</dfn></td>
            <td>bstr</td>
            <td>
                Initialization vector (nonce) used for encryption. The IVs size depends
                on the cipher used for encryption, e.g.:
                
                - AES256GCM: 12 bytes

                Note: A new and unique IV MUST be used for every encryption. One MUST NOT use the same IV twice! This can be achieved by using a counter or by using a cryptographically secure (pseudo) random number generator (CSRNG) to generate the IV at random.
            </td>
        </tr>
        <tr>
            <td><dfn>cmp</dfn></td>
            <td>int</td>
            <td>
                The following compression algorithms are supported:
                
                - None (0x00)
                - Gzip (0x01) [[!RFC1952]]
            </td>
        </tr>
        <tr>
            <td><dfn>kdf</dfn></td>
            <td>[[#kdf-map]]</td>
            <td>
                Values specific for the [[#key-derivation]]
            </td>
        </tr>
    </table>
</figure>

<pre class="example">
{"cid": 3, "iv": h'010203040102030401020304', "cmp": 1, "kdf": {"$UUID": h'9E298B1956DB4773B23DFC3EC6F0A1E6', "I": 2, "M": 4096, "P": 8, "S": h'0102030401020304010203040102030401020304010203040102030401020304'}}

A4                                      # map(4)
   63                                   # text(3)
      636964                            # "cid"
   03                                   # unsigned(3)
   62                                   # text(2)
      6976                              # "iv"
   4C                                   # bytes(12)
      010203040102030401020304          # "\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004"
   63                                   # text(3)
      636D70                            # "cmp"
   01                                   # unsigned(1)
   63                                   # text(3)
      6B6466                            # "kdf"
   A5                                   # map(5)
      65                                # text(5)
         2455554944                     # "$UUID"
      50                                # bytes(16)
         9E298B1956DB4773B23DFC3EC6F0A1E6 # "\x9E)\x8B\u0019V\xDBGs\xB2=\xFC>\xC6\xF0\xA1\xE6"
      61                                # text(1)
         49                             # "I"
      02                                # unsigned(2)
      61                                # text(1)
         4D                             # "M"
      19 1000                           # unsigned(4096)
      61                                # text(1)
         50                             # "P"
      08                                # unsigned(8)
      61                                # text(1)
         53                             # "S"
      58 20                             # bytes(32)
         0102030401020304010203040102030401020304010203040102030401020304 # "\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004"

A463636964036269764C01020304010203040102030463636D7001636B6466A565245555494
4509E298B1956DB4773B23DFC3EC6F0A1E6614902614D191000615008615358200102030401
020304010203040102030401020304010203040102030401020304
</pre>

#### KDF Parameters #### {#kdf-map}

The KDF parameters are used to derive a secret ([[#final-keys]]). The [=$UUID=] is mandatory and
defines which algorithm should be used as key derivation function. The other parameters are optional
and depend on the selected algorithm. All parameters associated with the specified algorithm MUST be 
present for a specific algorithm, otherwise the database is malformed. The fields SHOULD be encoded
in the order listed below.

<figure id="kdfParameterVariantMap" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Association</th>
        </tr>
        <tr>
            <td><dfn>$UUID</dfn></td>
            <td>bstr</td>
            <td>
                A 16 byte UUID indicating the key derivation algorithm. This should be
                the first entry of the map.
                
                - Argon2id: `9e298b19-56db-4773-b23d-fc3ec6f0a1e6`    
            </td>
            <td></td>
        </tr>
        <tr>
            <td><dfn>I</dfn></td>
            <td>uint</td>
            <td>
                Iterations, encoded within a u64.
            </td>
            <td>Argon2</td>
        </tr>
        <tr>
            <td><dfn>M</dfn></td>
            <td>uint</td>
            <td>
                Memory usage in KiB, encoded within a u64.
            </td>
            <td>Argon2</td>
        </tr>
        <tr>
            <td><dfn>P</dfn></td>
            <td>uint</td>
            <td>
                Parallelism encoded within a u32.
            </td>
            <td>Argon2</td>
        </tr>
        <tr>
            <td><dfn>S</dfn></td>
            <td>bstr</td>
            <td>
                Random salt, typically 32 bytes. 
            </td>
            <td>Argon2</td>
        </tr>
    </table>
</figure>

<pre class="example">
{"$UUID": h'9e298b1956db4773b23dfc3ec6f0a1e6', "I": 2, "M": 4096, "P": 8, "S": h'0102030401020304010203040102030401020304010203040102030401020304'}

A5                                      # map(5)
   65                                   # text(5)
      2455554944                        # "$UUID"
   50                                   # bytes(16)
      9E298B1956DB4773B23DFC3EC6F0A1E6  # "\x9E)\x8B\u0019V\xDBGs\xB2=\xFC>\xC6\xF0\xA1\xE6"
   61                                   # text(1)
      49                                # "I"
   02                                   # unsigned(2)
   61                                   # text(1)
      4D                                # "M"
   19 1000                              # unsigned(4096)
   61                                   # text(1)
      50                                # "P"
   08                                   # unsigned(8)
   61                                   # text(1)
      53                                # "S"
   58 20                                # bytes(32)
      0102030401020304010203040102030401020304010203040102030401020304 # "\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004\u0001\u0002\u0003\u0004"

A5652455554944509E298B1956DB4773B23DFC3EC6F0A1E6614902614D19100061500
861535820010203040102030401020304010203040102030401020304010203040102
0304
</pre>

### Key Derivation ### {#key-derivation}

The encryption key is derived from one or more sources of key data:

- a [[#password]],
- a [[#key-file]],
- or a [[#key-provider]]

#### Password #### {#password}

A password is the most common source of key data. It is set by a user during
database creation and is also referred to as the master password. It is recommendet
to use a strong password that fulfill the criteria published by reputable authorities, such as 
<a href="https://owasp.org/">OWASP</a> and <a href="https://www.nist.gov/">NIST</a>.

It is further recommendet that applications supporting the creation of CCDB databases
furhter support the user with the creation of a secure master password, including the
suggestion of randomized passwords.

#### Key File #### {#key-file}

A key file can serve as an input either alongside a password or as an alternative to the key derivation function used for deriving a symmetric encryption key. It's recommended that applications support a range of key file formats to enhance compatibility and flexibility.

Applications SHOULD support the following key file formats:

- **Raw**: A file containing exactly 32 bytes that make up the key.
- **Hex**: A file containing exactly 64 bytes that are interpreted as a hex encoded 32 byte key.
- **Misc**: A file of arbitrary length. The content of the file is hashed with SHA3-256 before being fed to the key derivation function.

#### Key Provider #### {#key-provider}

Key material MAY also be obtained from other sources, e.g., using the HMAC Secret Extension of CTAP2 [[fido-v2.1]]. 

#### Symmetric Key #### {#final-keys}

To generate a symmetric key, a key derivation function ([=kdf=]) is employed, which derives the key from either a password, key file or key provider. The input into this selected key derivation function is as follows, with its remaining arguments defined by [[#kdf-map]]:

<pre highlight="js">
password || keyFileContent || keyProviderContent
</pre>

It's essential to ensure that the string passed to the KDF is not empty. Therefore, an application must enforce the usage of at least one of the following sources:

- password
- key file
- key provider

The process for deriving a symmetric key for encryption is as follows:

<pre highlight="js">
symKey = KDF(password || keyFileContent || keyProviderContent)
</pre>

Note: It's important to note that the length of the symmetric key must be adjusted according to the selected cipher ([=cid=]). For example, for AES256GCM, one can utilize the default hash length of 32 bytes for the symmetric key.

##### Argon2id + Password

<pre class="example" highlight="js">
I: 2, M: 4096, P: 8, S: 0102030401020304010203040102030401020304010203040102030401020304
password: supersecret

compositeKey = f75778f7425be4db0369d09af37a6c2b9a83dea0e53e7bd57412e4b060e607f7 = SHA256("supersecret")
symKey = 1800b386aff0488a7a3720e014afd4b57d27c915ead08ed68ede40c225ce4e98 = Argon2id(compositeKey)
</pre>

## Body ## {#body}

Directly after the [[#outer-header]] follows the body, consisting of the body length (`u64`), a tag, and the encrypted body data.

<figure id="body" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Name</th>
            <th>Data Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>Body Length</dfn></td>
            <td>u64</td>
            <td>
                The length of the [=Encrypted Body Data=] in bytes.
            </td>
        </tr>
        <tr>
            <td><dfn>Body Tag</dfn></td>
            <td>byte[]</td>
            <td>
                The AEAD tag is the result of encrypting the Body Data using the AEAD cipher defined by [=cid=].
                The length N of the tag depends on the AEAD cipher used for encryption:
                - AES256GCM: `byte[16]`
            </td>
        </tr>
        <tr>
            <td><dfn>Encrypted Body Data</dfn></td>
            <td>byte[[=Body Length=]]</td>
            <td>
                The body data encrypted using the AEAD cipher defined by [=cid=] of length [=Body Length=].
            </td>
        </tr>
    </table>
</figure>

### Body Data Structure

The body data is a nested CBOR map (major type 5) consisting of [[#body-meta]], [[#body-group]], and [[#body-entry]] data items.

<figure id="rootBodyContent" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Optional</th>
        </tr>
        <tr>
            <td>meta (0x00)</td>
            <td>map</td>
            <td>
                Properties describing the database itself ([[#body-meta]]).
            </td>
            <td></td>
        </tr>
        <tr>
            <td><dfn>entries</dfn> (0x01)</td>
            <td>[+ [[#body-entry]]]</td>
            <td>
                All entries of this database.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>groups (0x02)</td>
            <td>[[#body-group]]</td>
            <td>
                The root of an arbitrary number of (nested) groups. Groups only hold references
                to entries within [=entries=].
            </td>
            <td></td>
        </tr>
        <tr>
            <td>bin (0x03)</td>
            <td>[+ [[#body-bin]] ]</td>
            <td>
                The bin is a array of elements of type [[#body-bin]] that
                represent deleted entries. This filed MAY NOT be present
                if no entries have been delted.
            </td>
            <td>Optional</td>
        </tr>
    </table>
</figure>

#### Bin Entry #### {#body-bin}

When a [[#body-entry]] is deleted it SHOULD NOT be removed directly but instead
moved into the [=Bin=]. Moving a deleted entry in the bin allows the user
to undo a deletion. Each application MAY define a limit after which a
deleted entry is permanently removed from the database.

<figure id="binEntry" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Optional</th>
        </tr>
        <tr>
            <td>time (0x00)</td>
            <td>uint</td>
            <td>
                Epoch-based date/time the entry was deleted.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>entry (0x01)</td>
            <td>map</td>
            <td>
                The deleted [[#body-entry]]. The exact location where the entry was deleted from is defined by [=Groups=].
            </td>
            <td></td>
        </tr>
    </table>
</figure>

#### Meta #### {#body-meta}

<figure id="metaBodyContent" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Optional</th>
        </tr>
        <tr>
            <td>gen (0x00)</td>
            <td>tstr</td>
            <td>
                The name of the application that created the database.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>name (0x01)</td>
            <td>tstr</td>
            <td>
                The name of the database.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>change (0x02)</td>
            <td>uint</td>
            <td>
                Epoch-based date/time. This field has to be updated each time the database content is changed. 
            </td>
            <td></td>
        </tr>
    </table>
</figure>

#### Group #### {#body-group}

<figure id="groupBodyContent" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Optional</th>
        </tr>
        <tr>
            <td>uuid (0x00)</td>
            <td>tstr</td>
            <td>
                A unique identifyer for the given group, e.g., UUIDv4 or UUIDv7 encoded as URN, e.g.:
                
                - `0e695c28-42f9-43e4-9aca-3f71cd701dc0`
            </td>
            <td></td>
        </tr>
        <tr>
            <td>name (0x01)</td>
            <td>tstr</td>
            <td>
                A human readable name for the given group.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>times (0x02)</td>
            <td>map</td>
            <td>
                Counters and time values (see [[#body-times]]).
            </td>
            <td></td>
        </tr>
        <tr>
            <td>groups (0x03)</td>
            <td>[+ [[#body-group]] ]</td>
            <td>
                An array of [[#body-group]]s.
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>entries (0x04)</td>
            <td>[+ tstr]</td>
            <td>
                An array of UUID references to entries.
            </td>
            <td>Optional</td>
        </tr>
    </table>
</figure>

#### Times #### {#body-times}

<figure id="timeContent" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Optional</th>
        </tr>
        <tr>
            <td>creat (0x00)</td>
            <td>uint</td>
            <td>
                Epoch-based date/time the parent was created.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>mod (0x01)</td>
            <td>uint</td>
            <td>
                Epoch-based date/time the parent was modified the last time.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>exp (0x02)</td>
            <td>uint</td>
            <td>
                Epoch-based date/time the parent will expire. The meaning of this field may vary depending on the parent.
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>cnt (0x03)</td>
            <td>uint</td>
            <td>
                Counter how many times the parent was used. The meaning of this field may vary depending on the parent.
            </td>
            <td>Optional</td>
        </tr>
    </table>
</figure>

<pre class="example">
{0x00: 1714585008, 0x01: 1714585008}

A2001A66327DB0011A66327DB0
</pre>

#### Entry #### {#body-entry}

<figure id="entryBodyContent" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Field</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Optional</th>
        </tr>
        <tr>
            <td>uuid (0x00)</td>
            <td>tstr</td>
            <td>
                A unique identifyer for the given entry, e.g., UUIDv4 or UUIDv7, encoded as URN, e.g.:

                - `0e695c28-42f9-43e4-9aca-3f71cd701dc0`
            </td>
            <td></td>
        </tr>
        <tr>
            <td>name (0x01)</td>
            <td>tstr</td>
            <td>
                A human readable name for the given entry.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>times (0x02)</td>
            <td>map</td>
            <td>
                Counters and time values (see [[#body-times]]).

                Note: For applications supporting passkeys, the UsageCount field might be of particular relevance
                but please be aware that counters make the synchronization between devices difficult and may lead
                to scenarios where the user locks himself out of his accounts.
            </td>
            <td></td>
        </tr>
        <tr>
            <td>notes (0x03)</td>
            <td>tstr</td>
            <td>
                Notes related to the given entry.
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>pw (0x04)</td>
            <td>tstr</td>
            <td>
                A password string.
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>key (0x05)</td>
            <td>map</td>
            <td>
                A CBOR Object Signing and Encryption (COSE) key [[!RFC8152]]. Also see Double Coordinate Curves, Octet Key Pair, and Symmetric Keys.
                
                **Double Coordinate Curve:**
                <pre class="example">
                {"kty": 2, "alg": -7, "crv": 1, "x": h'01020304...', "y": h'01020304...', "d": h'01020304...'}

                A6             # map(6)
                   63          # text(3)
                      6B7479   # "kty"
                   02          # unsigned(2) Elliptic Curve keys w/ x- and y-coordinate pair
                   63          # text(3)
                      616C67   # "alg"
                   26          # negative(6) ECDSA w/ SHA-256
                   63          # text(3)
                      637276   # "crv"
                   01          # unsigned(1) NIST P-256 also known as secp256r1
                   61          # text(1)
                      78       # "x"
                   44          # bytes(4)
                      01020304...  # Public key x-coordinate
                   61          # text(1)
                      79       # "y"
                   44          # bytes(4)
                      01020304...  # Public key y-coordinate
                   61          # text(1)
                      64       # "d"
                   44          # bytes(4)
                      01020304...  # Private key
                </pre>
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>url (0x06)</td>
            <td>tstr</td>
            <td>
                A text string representing a URL.
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>uname (0x07)</td>
            <td>tstr</td>
            <td>
                The user name corresponding to the given credential.
            </td>
            <td>Optional</td>
        </tr>
        <tr>
            <td>group (0x08)</td>
            <td>tstr</td>
            <td>
                A UUID (URN) referencing a [[#body-group]]. If not present, the given entry is implicitely
                associated to the group directly under the document root.
            </td>
            <td>Optional</td>
        </tr>
    </table>
</figure>

##### Example: Password Entry

<pre class="example">
{
  0x00: "0e695c28-42f9-43e4-9aca-3f71cd701dc0", 
  0x01: "Github", 
  0x02: {0x00: 1714585008, 0x01: 1714585008}, 
  0x03: "I should probably change my password.", 
  0x04: "supersecret"
}

A500782430653639356332382D343266392D343365342D396163612D33663731
6364373031646330016647697468756202A2001A66327DB0011A66327DB00378
25492073686F756C642070726F6261626C79206368616E6765206D7920706173
73776F72642E046B7375706572736563726574
</pre>

## Database Creation

Every application that supports the given standard should provide the flexibility to configure parameters that influence the behavior of the database. These parameters typically include the cipher, compression algorithm, and key derivation function. It's recommended that applications only propose sensible values for ciphers and key derivation functions sourced from reputable authorities, such as <a href="https://owasp.org/">OWASP</a> and <a href="https://www.nist.gov/">NIST</a>.

By allowing configuration of these parameters, applications empower users to tailor their security settings to best suit their specific needs and environments. This adaptability ensures compatibility with various security protocols and standards, fostering a robust and customizable security posture for the application.

## Serialization

During usage, the database typically exists in an intermediate form, largely contingent upon the programming language employed. 
Before persisting it to disk, the database must undergo serialization according to the following steps:

1. **Serialize Header Version**: Serialize the version of the header as specified in [[#header-version]].
2. **Header Field Length**: Allocate 4 bytes to reserve space for the length of the header fields.
3. **Generate Initialization Vector (IV)**: Create a new and unique initialization vector ([=iv=]), ensuring it is not reused.
4. Serialize the header fields, incorporating the [=iv=].
5. **Write Serialized Header Length**: Record the size of the serialized header fields within the 4 bytes reserved in the previous step.
6. **Encode the Body**: The body is encoded as specified by the guidelines outlined in the [[#body]] section.
7. **Compression (Optional)**: If the [=cmp=] header field is not set to None, compress the encoded body using the designated compression algorithm.
8. **Serialize Body Length**: Serialize the length of the body as a u64 data type.
9. **Encrypt the Body**: Utilize the cipher specified by [=cid=] to encrypt the body with the following parameters:
    - key: The symmetric key specified in [[#final-keys]].
    - Initialization Vector (IV): [=iv=]
    - Associated Data (AD): The serialized header and body length.
10. **Write Tag and Encrypted Body**: Place the resulting tag immediately after the body length, followed by the encrypted body.

## Deserialization

Before an application can use a database it has to be deserialized and decrypted
according to the following steps:

1. **Read Serialized Data**: Retrieve the serialized data from storage.
2. **Validate Version**: Read the [[#header-version]] and validate that [=sig=] equals `CCDB`.
3. **Extract Header Length**: Extract the length of the header from the serialized data.
4. **Extract Header**: Extract the header based on the header length.
5. **Validate Header**: Validate that all required header fields are present and contain sain values.
6. **Extract Body Length**: Extract the length of the body from the serialized data.
7. **Extract Tag and Encrypted Body**: Extract the tag followed by the encrypted body from the serialized data.
8. **Decrypt the Body**: Utilize the specified cipher and associated parameters to decrypt the encrypted body:
    - key: The symmetric key specified in [[#final-keys]].
    - Initialization Vector (IV): [=iv=]
    - Associated Data (AD): `Outer Header || Body Length` 
9. **Decompression (Optional)**: If compression was applied during serialization, decompress the encoded body using the designated decompression algorithm.
10. **Decode the Body**: Decode the body according to the specifications outlined in the [[#body]] section.

Security Considerations {#security}
=====================
