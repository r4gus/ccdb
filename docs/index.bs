<pre class='metadata'>
Title: KDBX Next Generation (kdbxng) Credential Database Format
Shortname: KDBXNG
Level: 1
Status: DREAM
Work Status: exploring 
Repository: https://github.com/r4gus/kdbxng
URL: https://r4gus.github.io/kdbxng/docs/index.html
Editor: David P. Sugar, david@thesugar.de
Abstract: foo bar
Warning: Not Ready
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: markdown yes, css no
</pre>

Introduction {#intro}
=====================

The problem of storing secrets securely is an important part of credential management;
unfortunately, most password managers and other applications managing secrets implement
their own, and some times proprietary, credential database scheme. One of the most
used database formats, used by many open source applications, is KDBX, defined by
KeePass, which is rather old and has some legacy issues.

This document proposes a new format for storing credentials at rest. The following goals are
being pursued:

Extensibility: The format allows to add new capabilities to the file format over time, and third parties should be able to enrich the information embedded in the file with proprietary extensions, with tools unaware of newer extensions being able to ignore them.

Resilience: The format protects the data using state-of-the-art cryptographic algorithms to ensure the confidentiality and integrity of the protected data.


General File Structure {#structure}
=====================

## General Block Structure ## {#general-block-structure}

The format builds upon the [pcapng](https://www.ietf.org/archive/id/draft-ietf-opsawg-pcapng-01.html)
file format, sharing many of general data structures. Readers familiar with the mentioned RFC draft should
recognize overlaping sections. The format has been chosen for its extensibility and linear structure with well defined
boundaries for every block.

A database file is organized in blocks, that are appended one to another to form the file. All the blocks share a common format, which is shown below.

<pre class="">
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 0 |                          Block Type                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 4 |                      Block Total Length                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 8 /                          Block Body                           /
   /              variable length, padded to 32 bits               /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Block Total Length                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The fields have the following meaning:

- Block Type (32 bits): a unique unsigned value that identifies the block. Values whose Most Significant Bit (MSB) is equal to 1 are reserved for local use. They can be used to make extensions to the file format to save private data to the file. The list of currently defined types can be found in [[#block-type-codes]].
- Block Total Length (32 bits): an unsigned value giving the total size of this block, in octets. For instance, the length of a block that does not have a body is 12 octets: 4 octets for the Block Type, 4 octets for the initial Block Total Length and 4 octets for the trailing Block Total Length. This value MUST be a multiple of 4.
- Block Body: content of the block.
- Block Total Length: total size of this block, in octets. This field is duplicated to permit backward file navigation.


This structure, shared among all blocks, makes it easy to process a file and to skip unneeded or unknown blocks. Some blocks can contain other blocks inside (nested blocks). Some of the blocks are mandatory, i.e. a capture file is not valid if they are not present, other are optional.

The General Block Structure allows defining other blocks if needed. A parser that does not understand them can simply ignore their content.

## Block Types

The currently standardized Block Type codes are specified in [[#block-type-codes]]; they have been grouped in the following two categories:

(1) Mandatory: The following block MUST appear at least once in each file:

- [[#header-block]]: It defines the most important characteristics of the database file.

(2) Optional: The following blocks MAY appear in a file:

Requests for new standardized Block Type codes should be made by creating a pull request to update this document.

## Logical Block Hierarchy

The blocks build a logical hierarchy as they refer to each other. The image below shows the logical hierarchy
of the currently defined blocks in the form of a "tree view":

<pre>
Database Header
 |
 +- Database Description
    +- Secrets 
    +- Group
       +- Secrets
       +- Group
          +- Secrets
</pre>

For example: each entry representing a credential refers to a specific database and optionally a group and the group also refers to a database or (nested) group.

## Physical File Layout

The file MUST begin with a Database Header Block. However, more than one Database Header Block can be present in the capture file, each 
one covering the data following it until the next one (or the end of file). A Database includes the data delimited by two Database Header 
Blocks (or by a Database Header Block and the end of the file), including the first Database Header Block.

In case an application cannot read a Database because of different version number, it MUST skip everything until the next Database Header Block. Note that, in order to properly skip the blocks until the next section, all blocks MUST have the fields Type and Length at the beginning. In order to properly skip blocks in the backward direction, all blocks MUST have the Length repeated at the end of the block. These are mandatory requirements that MUST be maintained in future versions of the block format.

The image below shows a typical file layout, with a single Database Header that covers the whole file.

<pre>
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| DHB v1.0  |                      Data                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

## Options ## {#options}

All the block bodies MAY embed optional fields. Optional fields can be used to insert some information
that may be useful in the context of the given block. Therefore, each tool can either read the content of 
the optional fields (if any), or skip some of them.

A block that may contain options must be structured so that the number of octets of data in the Block Body that precede the options can be determined from that data; that allows the beginning of the options to be found. That is true for all standard blocks that support options; for Custom Blocks that support options, the Custom Data must be structured in such a fashion. This means that the Block Length field (present in [[#structure]]) can be used to determine how many octets of optional fields, if any, are present in the block. That number can be used to determine whether the block has optional fields (if it is zero, there are no optional fields), to check, when processing optional fields, whether any optional fields remain, and to skip all the optional fields at once.

Options are a list of Type - Length - Value fields, each one containing a single value:

- Option Type (16 bits): an unsigned value that contains the code that specifies the type of the current option. Option types whose Most Significant Bit is equal to one are reserved for local use; therefore, there is no guarantee that the code used is unique among all database files (generated by other applications), and is most certainly not portable.
- Option Length (16 bits): an unsigned value that contains the actual length of the following 'Option Value' field without the padding octets.
- Option Value (variable length): the value of the given option, padded to a 32-bit boundary. The actual length of this field (i.e. without the padding octets) is specified by the Option Length field.

Requests for new standardized option codes for a given block should be made by creating a pull request to update this document.

If an option's value is a string, the value is not necessarily zero-terminated. Software that reads these files MUST NOT assume that strings are zero-terminated, and MUST NOT treat a zero-value octet as a string terminator. The length of the value is always given by the Option Length.

Some options may be repeated several times; for example, a block can have multiple comments. Other options may appear at most once in a given block.

The option list is terminated by an option which uses the special 'End of Option' code (opt_endofopt). Code that writes kdbxng files MUST put an opt_endofopt option at the end of an option list. Code that reads kdbxng files MUST NOT assume an option list will have an opt_endofopt option at the end; it MUST also check for the end of the block, and SHOULD treat blocks where the option list has no opt_endofopt option as if the option list had an opt_endofopt option at the end.

The format of the optional fields is shown below.

<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Option Type              |         Option Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                       Option Value                            /
/              variable length, padded to 32 bits               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
/                 . . . other options . . .                     /
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option Type == opt_endofopt |   Option Length == 0          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The following codes can always be present in any optional field:

<figure id="common-options" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Length</th>
            <th>Multiple allowed?</th>
        </tr>
        <tr>
            <td>`opt_endofopt`</td>
            <td>0</td>
            <td>0</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`opt_comment`</td>
            <td>1</td>
            <td>variable</td>
            <td>yes</td>
        </tr>
        <tr>
            <td>`opt_time`</td>
            <td>2</td>
            <td>40</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`opt_tag`</td>
            <td>3</td>
            <td>variable</td>
            <td>yes</td>
        </tr>
        <tr>
            <td>`opt_custom`</td>
            <td>2988/2989</td>
            <td>variable</td>
            <td>yes</td>
        </tr>
    </table>
</figure>

- `opt_endofopt`: The `opt_endofopt` option delimits the end of the optional fields. This option MUST NOT be repeated within a given list of options.
- `opt_comment`: The opt_comment option is a UTF-8 string containing human-readable comment text that is associated to the current block. Line separators SHOULD be a carriage-return + linefeed ('\r\n') or just linefeed ('\n'); either form may appear and be considered a line separator. The string is not zero-terminated, e.g.:
    - "If I have problems with my account I can contact box@example.com"
- `opt_time`: Time values occuring in the following order:
    - Last Modification Time (64 bits): The time the block was modified the last time as (signed) epoch time value in ms.
    - Creation Time (64 bits): The time the block was created the first time as (signed) epoch time value in ms.
    - Last Access Time (64 bits): The time the block was accessed the last time as (signed) epoch time value in ms.
    - Expiry Time (64 bits): The time the block will expire as (signed) epoch time value in ms. The meaning of this depends on the type of the block. A Expiry Time of 0 or less MUST be ignored.
    - Usage Count (64 bits): The number of times the block or its content was used as unsigned integer. The meaning of this depends on the type of the block. The field MAY be ignored.
- `opt_tag`: A tag associated with the given block.
- `opt_custom`: This option is described in detail in [[#custom-options]].

### Custom Options ### {#custom-options}

Customs Options are used for portable, vendor-specific data related to the block they're in. A Custom Option can be in any block type that can have options, can be repeated any number of times in a block, and may come before or after other option types - except the opt_endofopt option, which is always the last option. Different Custom Options, of different type codes and/or different Private Enterprise Numbers, may be used in the same kdbxng file.

<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Custom Option Type        |         Option Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Private Enterprise Number (PEN)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                        Custom Data                            /
/              variable length, padded to 32 bits               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The Custom Option has the following fields:

- Custom Option Type: The type code number for the Custom Option, which can be one of the following decimal numbers:
    - 2988: This option type code identifies a Custom Option containing a UTF-8 string in the Custom Data portion. The string is not zero-terminated.
    - 2989: This option type code identifies a Custom Option containing binary octets in the Custom Data portion.
- Option Length: as described in [[#general-block-structure]], this contains the length of the option's value, which includes the 4-octet Private Enterprise Number and variable-length Custom Data fields, without the padding octets.
- Private Enterprise Number: An IANA-assigned Private Enterprise Number identifying the organization which defined the Custom Option. The PEN MUST be encoded using the same endianness as the Database Header Block it is within the scope of, i.e., little endian.
- Custom Data: the custom data, padded to a 32 bit boundary.

## Data Format ## {#data-format}

### Endianness

Data contained in each section MUST be encoded in little endian format. This refers to all the fields that are saved as numbers and that span over two or more octets.

### Allignment

All fields of this specification use proper alignment for 16- and 32-bit values. This makes it easier and faster to read/write file contents if using techniques like memory mapped files.

The alignment octets (marked in this document e.g. with "padded to 32 bits") MUST be filled with zeroes.

Please note: 64-bit values are not aligned to 64-bit boundaries. This is because the file is naturally aligned to 32-bit boundaries only. Special care MUST be taken when reading and writing such values.

### Strings

If a string is specified as being encoded as UTF-8, software that reads that string MUST NOT assume that the string's value is valid UTF-8, and MAY discard a string that is not valid UTF-8 or MAY repair the string by replacing invalid octet sequences with valid sequences such as the sequence for a Unicode REPLACEMENT CHARACTER; software that writes that string fields MUST write only a valid UTF-8 string.

Block Definition {#block-definition}
=====================

## Database Header Block ## {#header-block}

The Database Header Block (DHB) is mandatory. It identifies the beginning of a section of the database file.
The Database Header Block contains all data required to en-/decrypt the files content.

<pre>
                       1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Block Type = 0x4b444258                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Block Total Length                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           TAG Length                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                              TAG                              /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Major Version        |         Minor Version         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   |                         Database Length                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           IV Length                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                               IV                              /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           CID Length                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                              CID                              /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                                                               /
   /                      Options (variable)                       /
   /                                                               /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Block Total Length                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The meaning of the fields is:

- Block Type: The block type of the Database Header Block is the integer corresponding to the 4-char string "KDBX" (0x4b444258).
- Block Total Length: total size of this block, as described in [[#general-block-structure]].
- TAG Length (32 bits): an unsigned value that contains the actual length of the following 'TAG' field without the padding octets.
- TAG (variable): a message authentication code (MAC) tag authenticating the given section, padded to 32 bits.
- Major Version (16 bits): an unsigned value, giving the number of the current major version of the format. The value for the current version of the format is 1.
- Minor Version (16 bits): an unsigned value, giving the number of the current minor version of the format. The value for the current version of the format is 0.
- Database Length (64 bits): a signed value specifying the length in octets of the following database, excluding the Database Header Block itself. This field can be used to skip the section, for faster navigation inside large files. If the Database Length is -1 (0xFFFFFFFFFFFFFFFF), this means that the size of the section is not specified, and the only way to skip the section is to parse the blocks that it contains. Please note that if this field is valid (i.e. not negative), its value is always a multiple of 4, as all the blocks are aligned to and padded to 32-bit (4 octet) boundaries.
- IV Length (32 bits): an unsigned value that contains the actual length of the following 'IV' field without the padding octets.
- IV (variable): The initialization vector, also called nonce, used for the cipher specified in 'CID', padded to 32 bits.
- CID Length (32 bits): an unsigned value that contains the actual length of the following 'CID' field without the padding octets.
- CID (variable): The cipher suite identifier as specified in [[#cipher-suites]], padded to 32 bits.
- Options: optionally, a list of options (formatted according to the rules defined in [[#options]]) can be present.

Writers of kdbxng files MUST NOT write DHBs with a Major Version other than 1 or a Minor Version other than 0. If they do so, they will write a file that many readers of kdbxng files are not to be able to read.

The Major Version would be changed only if a new version of this specification, for a later major version of the file format, were created. Such a version would only be created if the format were to change in such a way that code that reads the new format could not read the old format (i.e., code to read both formats would have to check the version number and use different code paths for the two formats) and code that reads the old format could not read the new format. An incompatible change to the format of an existing block or an existing option would be such a change; the addition of a new block or a new option would not be such a change. An example of such an incompatible change would be the addition of an additional field to the Database Header Block, following the Minor Version field and before the Snaplen field; software expecting the new DHB format would not correctly read the old DHB format, and software expecting the old DHB format would not correctly read the new DHB format.

The Minor Version would be changed only if a new version of this specification, for a later minor version of the file format, were created. Such a version would only be created if the format were to change in such a way that code that reads the new format could read the old format without checking the version number but code that reads the old format could not read all files in the new format. A backward-compatible change to the format of an existing block or an existing option would be such a change; the addition of a new block or a new option would not be such a change. 

In addition to the options defined in [[#options]], the following options are valid within this block and MAY be required depending on the selected cipher suite (see [[#cipher-suites]]):

<figure id="common-options" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Length</th>
            <th>Multiple allowed?</th>
        </tr>
        <tr>
            <td>`kdf_iterations`</td>
            <td>32</td>
            <td>4</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`kdf_memory`</td>
            <td>33</td>
            <td>4</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`kdf_parallelism`</td>
            <td>34</td>
            <td>4</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`kdf_salt`</td>
            <td>35</td>
            <td>variable</td>
            <td>no</td>
        </tr>
    </table>
</figure>

- `kdf_iterations`: The number of iterations for the key derivation function specified by CID. This option MUST be present if one of the following cipher suites have been selected:
    - `KDBXNG_XCHACHA20_POLY1305_ARGON2ID`
- `kdf_memory`: The memory usage of the key derivation function in KiB. This option MUST be present if one of the following cipher suites have been selected:
    - `KDBXNG_XCHACHA20_POLY1305_ARGON2ID`
- `kdf_parallelism`: The parallelism of the key derivation function, i.e., the number of threads to use. This option MUST be present if one of the following cipher suites have been selected:
    - `KDBXNG_XCHACHA20_POLY1305_ARGON2ID`
- `kdf_salt`: A salt used as additional input into the key derivation function. This option MAY be present if one of the following cipher suites have been selected and MUST be used if present:
    - `KDBXNG_XCHACHA20_POLY1305_ARGON2ID`



### Cipher Suites ### {#cipher-suites}

The cipher suite defines all algorithms required to correctly decrypt the given section. The following cipher suites MUST be supported by a implementation:

- `KDBXNG_XCHACHA20_POLY1305_ARGON2ID`: XChaCha20 as authenticated cipher with Poly1305 and Argon2id for key derivation.

### KDF Field ### {#kdf-field}

## Secrets Block ## {#secrets-block}

A Secrets Block (SB) stores some sort of cryptographic key and related
data to be used in the context of cryptography. The format of these
secrets is defined by the Secrets Type.

Multiple SBs can exist in a kdbxng file.

The structure of a Decryption Secrets Block is shown below.

<pre>
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 0 |                   Block Type = 0x00000300                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 4 |                      Block Total Length                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 8 /                                                               /
   /                             UUID                              /
   /                                                               /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
24 |                          Secrets Type                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
28 |                         Secrets Length                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
32 /                                                               /
   /                          Secrets Data                         /
   /              (variable length, padded to 32 bits)             /
   /                                                               /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                                                               /
   /                       Options (variable)                      /
   /                                                               /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   /                       Block Total Length                      /
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The Enhanced Packet Block has the following fields:

- Block Type: The block type of the Decryption Secrets Block is 0x300.
- Block Total Length: total size of this block, as described in [[#general-block-structure]].
- UUID (128 bits): A UUID Version 7 as defined by [[!RFC9562]].
- Secrets Type (32 bits): an unsigned integer identifier that describes the format of the following Secrets field. Requests for new Secrets Type codes should be made by creating a pull request to update this document.
- Secrets Length (32 bits): an unsigned integer that indicates the size of the following Secrets field, without any padding octets.
- Secrets Data: binary data containing secrets, padded to a 32 bit boundary.
- Options: optionally, a list of options (formatted according to the rules defined in [[#options]]) can be present.

The following is a list of Secrets Types:

- `0x004a574b`: JSON Web Key (JWK). This format is described in [[!RFC7517]]. Cryptographic algorithms and identifiers for use with JWKs are described in [[!RFC7517]].
- `0x0050454d`: A PEM encoded secret. This format is described in [[!RFC7468]]. Readers and writers supporting this format MUST support the public key (`BEGIN PUBLIC KEY`/`END PUBLIC KEY`) and private key (`BEGIN PRIVATE KEY`/`END PRIVATE KEY`; see [[!RFC5958]]) in DER encoding. Readers SHOULD expect Secrets Data to contain multiple keys and certificates appended to each other.
- `0x00505744`: A password.

Readers and writers MAY NOT implement all supported Secrets Types. Readers MAY ignore blocks with an
unsupported type. Readers SHOULD NOT modify unsupported blocks. Writers MUST generate only valid
data based on the selected Secrets Type.

In addition to the options defined in [[#options]], the following options are valid within this block:

<figure id="secrets-options" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Length</th>
            <th>Multiple allowed?</th>
        </tr>
        <tr>
            <td>`sec_title`</td>
            <td>64</td>
            <td>variable</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`sec_url`</td>
            <td>65</td>
            <td>variable</td>
            <td>no</td>
        </tr>
        <tr>
            <td>`sec_url`</td>
            <td>65</td>
            <td>variable</td>
            <td>no</td>
        </tr>
    </table>
</figure>

- `sec_title`: A human readable name or title associated with the given secret. 
- `sec_url`: A valid URL associated with the given secret. This can be used to associate a secret with a specific (online) service. In the context of a passkey (FIDO2 credential), this option MUST be used to store the relying party id (rpId).

Standardized Block Type Codes {#block-type-codes}
=====================

<figure id="block-type-codes-table" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Block Type Code</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>0x00000001</td>
            <td>Asymmetric Secrets Block</td>
        </tr>
        <tr>
            <td>0x4b444258</td>
            <td>Database Header Block</td>
        </tr>
    </table>
</figure>

Thread Model {#thread-modell}
=====================

## Assumptions

<figure id="thread-assumptions" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Identifier</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>A_UNTRUSTED_STORAGE_LOCATION</dfn></td>
            <td>
                The file may be stored in a untrusted location, e.g., a unprotected USB stick or file share.
            </td>
        </tr>
        <tr>
            <td><dfn>A_TRUSTED_PROCESSING_ENVIRONMENT</dfn></td>
            <td>
                The file is only decrypted and processed in a trusted processing environment.
            </td>
        </tr>
    </table>
</figure>

## Threads

<figure id="thread-threads" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Identifier</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>T_FILE_ACCESS</td>
            <td>
                The file is accessed at rest by a untrusted person. Applicable because of [=A_UNTRUSTED_STORAGE_LOCATION=].
                Mitigated by [=M_ENCRYPTION=].
            </td>
        </tr>
        <tr>
            <td>T_FILE_MANIP</td>
            <td>
                The file is manipulated at rest by a untrusted person. Applicable because of [=A_UNTRUSTED_STORAGE_LOCATION=].
                Mitigated by [=M_INTEGRITY=].
            </td>
        </tr>
        <tr>
            <td>T_MEMORY_ACCESS</td>
            <td>
                The memory is accessed while reading or writing the database by a malicious actor. Not applicable because
                of [=A_TRUSTED_PROCESSING_ENVIRONMENT=]. A kdbxng file MUST NOT be processed on a untrusted system.
            </td>
        </tr>
        <tr>
            <td>T_MEMORY_MANIP</td>
            <td>
                The memory is manipulated while reading or writing the database by a malicious actor.  Not applicable because
                of [=A_TRUSTED_PROCESSING_ENVIRONMENT=]. A kdbxng file MUST NOT be processed on a untrusted system.
            </td>
        </tr>
    </table>
</figure>

## Mitigations

<figure id="thread-mitigations" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Identifier</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><dfn>M_ENCRYPTION</dfn></td>
            <td>
                The file is encrypted using a state-of-the-art cipher.
            </td>
        </tr>
        <tr>
            <td><dfn>M_INTEGRITY</dfn></td>
            <td>
                The integrity of the file is verified using a message authenticaiton code.
            </td>
        </tr>
    </table>
</figure>

## Policies

The following policies SHOULD be considered by applications supporting the format defined within this specification.

<figure id="policies" class="table">
    <table class="complex data longlastcol">
        <tr>
            <th>Identifier</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>P_MEM_PROTECT</td>
            <td>
                The memory of readers and writers should be handeled with care. This SHOULD include but is
                is not limited to mitigations like [mlock](https://www.man7.org/linux/man-pages/man2/mlock.2.html)
                on UNIX like systems.
            </td>
        </tr>
    </table>
</figure>

File Encryption {#file-encryption}
=====================

Every database SHOULD be stored encrypted at rest to ensure the confidentiality, integrity, and authenticity of the data.
The cipher suite to be used with a given database is defined by the CID of the corresponding [[#header-block]]. The CID defines the cipher, mac, and (password) key derivation function to be used to en-/decryt
the database. 

## Key Derivation

The symmetric key used for the en-/decryption of the databse is derived from one or more
sources of key data:

- Password
- Key File
- Key Provider

### Password

A password is the most common source of key data. It is set by a user during database creation and is also referred to as the master password. It is recommended to use a strong password that fulfill the criteria published by reputable authorities, such as OWASP and NIST.

It is further recommended that applications supporting the creation of kdbxng databases further support the user with the creation of a secure master password, including the suggestion of randomized passwords.

### Key File

A key file stores a (random) sequence of octets used with a KDF. Applications SHOULD support the following key file formats:

- Raw: A file containing exactly 32 bytes that make up the key.

- Hex: A file containing exactly 64 bytes that are interpreted as a hex encoded 32 byte key.

### Key Provider

Key material MAY also be obtained from other sources, e.g., using the HMAC Secret Extension of CTAP2 [[!FIDO-v2.1]]. Currently this standard doesn't include any key providers.

### Symmetic Key Derivation

To generate a symmetric key, a (password) key derivation function (KDF) is employed, which derives the key from one or more key sources. The input to this function MUST NOT be empty and must contain the following sequence as an argument: `password || keyFileContent || keyProviderContent`. The process for deriving a symmetic key for en-/decryption is as follows:

<pre>
symKey = KDF(password || keyFileContent || keyProviderContent)
</pre>

Note: Itâ€™s important to note that the length of the symmetric key must be adjusted according to the selected cipher. Most KDFs, including Argon2, allow the generiation of secrets with differnt lengths "out-of-the-box".

## File En-/Decryption

All consecutive blocks between the Database Header Block and the next Database Header Block or the end of file are encrypted
using the selected authenticated encryption with associated data (AEAD) cipher. Before encryption, a new and unique IV MUST 
be generated and placed in the IV field of the Database Header Block. Writers MUST NOT reuse the IV for encryptions.
The cipher takes a part of the Database Header Block as associated data (see [[#integrity-check]]). 

Note: Please keep in mind that, depending on the length of the IV, it might not be secure to generate the IV using a CSPRNG.

## Integrity Check ## {#integrity-check}

To ensure the integrity and authenticity, a message authentication code (MAC), also knwon as
a keyed hash function, is applied. The message authentication code is generated as a side effect
of encrypting the database using the selected authenticated encryption with associated data (AEAD) cipher.
All data of the Database Header Block following the TAG up to and including the trailing Block Total Length
is considered associated data.

The generated message authentication code tag is written to the TAG field of the Database Header Block.

Note: An application that doesn't want to decrypt the whole database at once, e.g., because it wants to
minimize the exposure of sensitive information in memory, MAY verify the MAC independently. In that case,
the application MUST follow the same steps the AEAD cipher would to generate the correct hash message, e.g.,
the insertion of padding between associated data and encrypted data.

Recommended File Name Extension: .kdbxng {#recommendet-extension}
=====================

The recommended file name extension for the "KDBX Next Generation File Format" specified in this document is ".kdbxng".

On Windows and macOS, files are distinguished by an extension to their filename. Such an extension is technically not actually required, as applications should be able to automatically detect the kdbxng file format through the "magic bytes" at the beginning of the file, as some other UN*X desktop environments do. However, using name extensions makes it easier to work with files (e.g. visually distinguish file formats) so it is recommended - though not required - to use .kdbxng as the name extension for files following this specification.
